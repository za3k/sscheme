; Constants
() => ()
nil => nil
#t => #t
#f => #f

; Number parsing
1 => 1
10 => 10
100 => 100
-10 => -10
-symbol_name => err

; Decimal, Octal, Hex parsing
#d10 => 10
#o10 => 8
#x10 => 16
#d-10 => -10
#o-10 => -8
#x-10 => -16
#d12 => 12
#o12 => 10
#x12 => 18
#x100 => 256

; Character constants
#\a => #\a
#\m => #\m
#\z => #\z
#\A => #\A
#\M => #\M
#\Z => #\Z
#\nul => #\nul
#\soh => #\soh
#\bel => #\bel
#\bs  => #\bs
#\lf  => #\lf
#\vt  => #\vt
#\cr  => #\cr
#\esc => #\esc
#\sp  => #\sp
#\del => #\del
#\alarm     => #\bel
#\backspace => #\bs
#\tab       => #\ht
#\linefeed  => #\lf
#\newline   => #\lf
#\vtab      => #\vt
#\page      => #\ff
#\return    => #\cr
#\escape    => #\esc
#\space     => #\sp
#\delete    => #\del

; String parsing

"abc" => "abc"
"" => ""
" => err
"'" => "'"
"\"" => "\""
"\\" => "\\"
"\a" => "\a"
"\b" => "\b"
"\f" => "\f"
"\n" => "\n"
"\r" => "\r"
"\t" => "\t"
"\v" => "\v"
"\d" => "d"

; Lists
(1 2 3) => err
(list 1 2 3) => (1 2 3)
(quote (1 2 3)) => (1 2 3)

; Primitive/symbol resolution
+ => +
- => -
car => car
cdr => cdr
cons => cons
eq? => eq?
list => list
pair? => pair?
number? => number?
display => display
procedure? => procedure?
else => #t
NewVar => err

; Make sure multiple expressions works
1 2 => 2

; Tests for each form
(quote) => err
(quote 1 2) => err
(quote a) => :a
(quote 1) => 1
(quote ()) => ()
(quote quote) => :quote
(quote NewVar) => :NewVar
(quote nil) => :nil
(quote #t) => #t
(quote #f) => #f
(quote (a b c)) => (:a :b :c)

((lambda () 1)) => 1
((lambda (x) 1) 2) => 1
((lambda (x) x) 1) => 1
((lambda (x y) x) 1 2) => 1
((lambda (x y) y) 1 2) => 2
(lambda (x) x) => proc
((lambda (x y) (x y)) car (list 2 3)) => 2
((lambda (x y) (x y)) (lambda (y) (car y)) (list 2 3)) => 2

(cond (((eq? 2 3) (quote a)) ((eq? 2 4) 5) (else (quote b)))) => :b
(cond (((eq? 2 3) (quote a))
       ((eq? 2 4) 5)
       (else (quote b))))
    => :b
(cond (((eq? 2 3) (quote a))
       ((eq? 4 4) 5)
       (else (quote b))))
    => 5
(cond (((eq? 2 2) (quote a))
       ((eq? 2 4) 5)
       (else (quote b))))
    => :a

(define x 2) x => 2
(define x 1) (define y 2) x => 1
(define x 1) (define y 2) y => 2
(define x car) x => car

(define x 1)
(define y 2)
x => 1

(define-macro f (lambda (x y) (list x y))) (f car (list 1 2)) => 1

; Tests for each builtin
(list) => ()
(list 1) => (1)
(list 1 2) => (1 2)
(list 1 2 3) => (1 2 3)
(list 1 (list 2 (list 3))) => (1 (2 (3)))

(+) => err
(+ 1) => 1
(+ 1 2) => 3
(+ 1 2 3) => 6
(+ 1 (list 2 3) 4) => err

(-) => err
(- 5) => -5
(- 10 2) => 8
(- 2 10) => -8
(- 1 2 3) => err
(- 1 2 3 4) => err
(- 1 (list 1 2)) => err

; Tests for the standard library
(if #t 1 2) => 1
(if #f 1 2) => 2
(if (= 2 2) (+ 3 3) (+ 4 4)) => 6

(not 4) => #f
(not #t) => #f
(not #f) => #t

(first (list 1 2 3 4 5 6 7 8 9 10)) => 1
(second (list 1 2 3 4 5 6 7 8 9 10)) => 2
(third (list 1 2 3 4 5 6 7 8 9 10)) => 3
(fourth (list 1 2 3 4 5 6 7 8 9 10)) => 4
(fifth (list 1 2 3 4 5 6 7 8 9 10)) => 5
(sixth (list 1 2 3 4 5 6 7 8 9 10)) => 6
(seventh (list 1 2 3 4 5 6 7 8 9 10)) => 7
(eighth (list 1 2 3 4 5 6 7 8 9 10)) => 8
(ninth (list 1 2 3 4 5 6 7 8 9 10)) => 9
(tenth (list 1 2 3 4 5 6 7 8 9 10)) => 10
(last (list 1 2 3 4 5 6 7 8 9 10)) => 10
(rest (list 1 2 3 4 5 6 7 8 9 10)) => (2 3 4 5 6 7 8 9 10)

(list? ()) => #t
(list? (list 1 2 3)) => #t
(list? (cons 1 2)) => #f
(list? 2) => #f

(length ()) => 0
(length (list 2 3 4)) => 3

(map (lambda (x) (+ x 10)) (list 1 2 3)) => (11 12 13)

(append (list 1 2 3) (list 4 5 6)) => (1 2 3 4 5 6)
(append (list 1 2 3) ()) => (1 2 3)
(append () (list 4 5 6)) => (4 5 6)
(append () ()) => ()

(reverse (list 1 2 3)) => (3 2 1)
(reverse ()) => ()
(reverse (list 1)) => (1)

(list-tail (quote (a b c)) 1) => (:b :c)
(list-ref (quote (a b c)) 1) => :b
(list-ref (list 10 11 12) 1) => 11

(foldl + 0 (list 10 11 12)) => 33
(foldr + 0 (list 10 11 12)) => 33
(filter number? (list 10 #\d 13 "hello" (quote b))) => (10 13)

(remove 2 (list 1 2 3) eq?) => (1 3)
(remove 2 (list 1 2 3 2) eq?) => (1 3 2)
(remq 2 (list 1 2 3)) => (1 3)
(remq 2 (list 1 2 3 2)) => (1 3 2)

(assoc 3 (list (list 1 2) (list 3 4) (list 5 6)) eq?) => (3 4)
(assq 3 (list (list 1 2) (list 3 4) (list 5 6))) => (3 4)
(assv 3 (list (list 1 2) (list 3 4) (list 5 6))) => (3 4)
(assf number? (list (list #\d 2) (list 3 4) (list 5 6))) => (3 4)

(= (+ 2 2) 4) => #t
(= (+ 1 2) 4) => #f
