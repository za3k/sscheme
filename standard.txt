(define empty? null?)
(define eqv? eq?)
(define = eq?)
(define else #t)

(define-macro (if x y z)
  (list cond (list x y) (list else z)))
(define (not x) (if x #f #t))

; Helpers for later definitions
(define (map f l) ; todo varargs
  (if (null? l) l
      (cons (f (car l))
            (map f (cdr l)))))
(define (foldl proc init lst) ; todo vargs
  (if (null? lst)
      init
      (foldl proc (proc (car lst) init) (cdr lst))))
(define (foldr proc init lst) ; todo vargs
  (foldl proc init (reverse lst)))
(define (filter pred lst)
  (if (null? lst)
      lst
      (if (pred (car lst))
          (cons (car lst) (filter pred (cdr lst)))
          (filter pred (cdr lst)))))
  
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))
(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)
(define fourth cadddr)
(define (fifth x) (car (cddddr x)))
(define (sixth x) (cadr (cddddr x)))
(define (seventh x) (caddr (cddddr x)))
(define (eighth x) (cadddr (cddddr x)))
(define (ninth x) (car (cddddr (cddddr x))))
(define (tenth x) (cadr (cddddr (cddddr x))))

(define (last l)
 (if (null? (cdr l))
     (car l)
     (last (cdr l))))
(define (list? l)
 (if (null? l) 
     #t
     (if (pair? l)
         (list? (cdr l))
         #f)))
(define (length l)
  (if (null? l)
      0
      (+ 1 (length (cdr l)))))
(define (append l1 l2) ; todo varargs
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
(define (reverse l)
  (if (null? l)
      l
      (append (reverse (cdr l)) (list (car l)))))
(define (list-tail lst pos)
  (if (= pos 0) lst
      (list-tail (cdr lst) (- pos 1))))
(define (list-ref lst pos)
  (car (list-tail lst pos)))

(define (remove v lst proc) ; todo proc=equal? optional
  (if (null? lst) lst
      (if (proc v (car lst))
          (cdr lst)
          (cons (car lst) (remove v (cdr lst) proc)))))
(define (remq v lst) (remove v lst eq?))
(define (remv v lst) (remove v lst eqv?))

(define (assf pred lst)
  (if (null? lst)
      #f
      (if (pred (caar lst))
          (car lst)
          (assf pred (cdr lst)))))
(define (assoc v lst is-equal?) ; todo is-equal?=equal? is optional
  (assf (lambda (k) (is-equal? k v))
        lst))
(define (assv v lst) (assoc v lst eqv?))
(define (assq v lst) (assoc v lst eq?))

(define (boolean? x)
  (cond ((eq? x #t) #t)
        ((eq? x #f) #t)
        ((else) #f)))

; Waiting on and/or: memq memv member

; TODO list

; ' if set! case and or let let* letrec begin do quasiquote

; General
; equal? write display newline

; Numbers
; quotient remainder modulo
; / * max min abs gcd lcm expt
; = < > <= >=
; zero? positive? negative? odd? even?
; number->string string->number
; range

; boolean?

; Lists and pairs
; set-car! set-cdr!
; list? length append reverse list-tail list-ref memq memv member assq assv assoc 

; Symbol
; symbol->string string->symbol

; Characters
; char->integer integer->char
; char? char=? char<? char>? char<=? char>=?
; char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?
; char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case?
; char-upcase char-downcase

; Strings
; string->list list->string
; string? string string-length string-ref string=? string-ci=? string<? string>? string<=? string>=? string-ci<? string-ci>? string-ci<=? string-ci>=? substring string-append

; apply eval
; map for-each force delay
; scheme-report-environment null-environment interaction-environment
; call/cc
; call-with-current-continuation values call-with-values call-with-values dynamic-wind

; IO
; read read-char peek-char eof-object? char-ready? write display newline write-char

; Files
; load transcript-on transcript-off call-with-input-file call-with-output-file input-port? output-port? current-input-port current-output-port with-input-from-file with-output-to-file open-input-file open-output-file close-input-port close-output-port

5
