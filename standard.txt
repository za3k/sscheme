; ============== BUILTINS ================
; TODO: set! set-cdr! set-car! '

; TODO: symbol->string string->symbol
; TODO: number->string string->number
; TODO: string->list list->string
; TODO: char->integer integer->char

; ============== ALIASES ================
(define empty? null?)
(define eqv? eq?)
(define = eq?)
(define else #t)
(define / quotient)

; ============== FORMS (MACROS) ================
(define (list . x) x) ; Not a macro but very needed until we get ' notation
(define-macro (if x y z)
  (list (quote cond) (list x y) (list else z)))
(define-macro (and . clauses)
  (cond ((null? clauses) #t)
        ((null? (cdr clauses)) (car clauses))
        (else
            (list (quote if) (car clauses)
                             (cons (quote and) (cdr clauses))
                             #f))))
(define-macro (or . clauses) ; Note - this evaluates the truthy clause twice
  (cond ((null? clauses) #f)
        (else
            (list (quote if) (car clauses)
                             (car clauses)
                             (cons (quote or) (cdr clauses))))))

; TODO: case let let* letrec begin do quasiquote for-each
; TODO: force delay

; ============== BOOLEANS ================
(define (boolean? x)
  (or (eq? x #t) (eq? x #f)))
(define (not x) (if x #f #t))

; ============== HELPERS ================
; Helpers for later definitions
(define (map f l) ; todo varargs
  (if (null? l) l
      (cons (f (car l))
            (map f (cdr l)))))
(define (foldl proc init lst) ; todo vargs
  (if (null? lst)
      init
      (foldl proc (proc init (car lst)) (cdr lst))))
(define (foldr proc init lst) ; todo vargs
  (foldl proc init (reverse lst)))
(define (filter pred lst)
  (if (null? lst)
      lst
      (if (pred (car lst))
          (cons (car lst) (filter pred (cdr lst)))
          (filter pred (cdr lst)))))
  
; TODO: equal? 

; ============== NUMBERS ================
; Upgrade to builtins to support not exactly 2 arguments: - + * / < <= > >= =
; TODO: < <= > >= =
(define _builtin- -)
(define _builtin+ +)
(define _builtin* *)
(define _builtin/ /)
(define _builtin< <)
(define (+ . lst)
    (cond ((null? lst) (error "WRONG_NUM_ARGUMENTS"))
          (else (foldl _builtin+ 0 lst))))
(define (- . lst)
    (cond ((= (length lst) 1) (_builtin- 0 (car lst)))
          ((= (length lst) 2) (_builtin- (car lst) (cadr lst)))
          (else (error "WRONG_NUM_ARGUMENTS"))))
(define (* . lst) (foldl _builtin* 1 lst))
(define (/ . lst)
    (cond ((null? lst) (error "WRONG_NUM_ARGUMENTS"))
          ((= (length lst) 1) (_builtin/ 1 (car lst)))
          (else (foldl _builtin/ (car lst) (cdr lst)))))

;(define (< . lst)
;  (cond ((null? lst) (error "WRONG_NUM_ARGUMENTS"))
;        ((null? (cdr lst)) #t)
;        ((not (_builtin< (first lst) (second lst))) #f)
;        (apply < (cdr lst))))

(define (max . lst)
  (foldl (lambda (x y) (if (< x y) y x))
         (car lst)
         (cdr lst)))
(define (min . lst)
  (foldl (lambda (x y) (if (< x y) x y))
         (car lst)
         (cdr lst)))
(define (negative? x) (< x 0))
(define (positive? x) (< 0 x))
(define (zero? x) (= x 0))
(define (remainder x y)
 (- x (* (quotient x y) y)))
(define (modulo x y)
 (if (or (and (negative? x) (negative? y))
         (and (not (negative? x)) (positive? y)))
     (remainder x y)
     (+ (remainder x y) y)))
(define (even? x) (= (modulo x 2) 0))
(define (odd? x) (= (modulo x 2) 1))
(define (abs x) (if (negative? x) (- x) x))

; TODO: gcd lcm expt
; TODO: range

; ============== LISTS AND PAIRS ================
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (caar x)))
(define (caadr x) (car (cadr x)))
(define (cadar x) (car (cdar x)))
(define (caddr x) (car (cddr x)))
(define (cdaar x) (cdr (caar x)))
(define (cdadr x) (cdr (cadr x)))
(define (cddar x) (cdr (cdar x)))
(define (cdddr x) (cdr (cddr x)))
(define (caaaar x) (car (caaar x)))
(define (caaadr x) (car (caadr x)))
(define (caadar x) (car (cadar x)))
(define (caaddr x) (car (caddr x)))
(define (cadaar x) (car (cdaar x)))
(define (cadadr x) (car (cdadr x)))
(define (caddar x) (car (cddar x)))
(define (cadddr x) (car (cdddr x)))
(define (cdaaar x) (cdr (caaar x)))
(define (cdaadr x) (cdr (caadr x)))
(define (cdadar x) (cdr (cadar x)))
(define (cdaddr x) (cdr (caddr x)))
(define (cddaar x) (cdr (cdaar x)))
(define (cddadr x) (cdr (cdadr x)))
(define (cdddar x) (cdr (cddar x)))
(define (cddddr x) (cdr (cdddr x)))
(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)
(define fourth cadddr)
(define (fifth x) (car (cddddr x)))
(define (sixth x) (cadr (cddddr x)))
(define (seventh x) (caddr (cddddr x)))
(define (eighth x) (cadddr (cddddr x)))
(define (ninth x) (car (cddddr (cddddr x))))
(define (tenth x) (cadr (cddddr (cddddr x))))

(define (last l)
 (if (null? (cdr l))
     (car l)
     (last (cdr l))))
(define (list? l)
 (if (null? l) 
     #t
     (if (pair? l)
         (list? (cdr l))
         #f)))
(define (length l)
  (if (null? l)
      0
      (+ 1 (length (cdr l)))))
(define (append l1 l2) ; todo varargs
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
(define (reverse l)
  (if (null? l)
      l
      (append (reverse (cdr l)) (list (car l)))))
(define (list-tail lst pos)
  (if (= pos 0) lst
      (list-tail (cdr lst) (- pos 1))))
(define (list-ref lst pos)
  (car (list-tail lst pos)))

(define (remove v lst proc) ; todo proc=equal? optional
  (if (null? lst) lst
      (if (proc v (car lst))
          (cdr lst)
          (cons (car lst) (remove v (cdr lst) proc)))))
(define (remq v lst) (remove v lst eq?))
(define (remv v lst) (remove v lst eqv?))

(define (assf pred lst)
  (if (null? lst)
      #f
      (if (pred (caar lst))
          (car lst)
          (assf pred (cdr lst)))))
(define (assoc v lst is-equal?) ; todo is-equal?=equal? is optional
  (assf (lambda (k) (is-equal? k v))
        lst))
(define (assv v lst) (assoc v lst eqv?))
(define (assq v lst) (assoc v lst eq?))

; TODO: memq memv member

; ============== CHARACTERS ================
; TODO: char=? char<? char>? char<=? char>=?
; TODO: char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?
; TODO: char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case?
; TODO: char-upcase char-downcase

; ============== STRINGS ================
; TODO: string string-length string-ref string=? string-ci=? string<? string>? string<=? string>=? string-ci<? string-ci>? string-ci<=? string-ci>=? substring string-append

; ============== SYMBOLS ================
; (none)

; ============== I/O ================
; TODO: write display newline
; TODO: read read-char peek-char eof-object? char-ready? write display newline write-char
; TODO: load transcript-on transcript-off call-with-input-file call-with-output-file input-port? output-port? current-input-port current-output-port with-input-from-file with-output-to-file open-input-file open-output-file close-input-port close-output-port

; ============== CONTINUATIONS AND ENVIRONMENT ================
; TODO: scheme-report-environment null-environment interaction-environment
; TODO: call-with-current-continuation values call-with-values call-with-values dynamic-wind

; ============== MISC ================
; TODO: standard error messages
; TODO: support default values in lambda syntax?
