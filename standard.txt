; ============== BUILTINS ================
; TODO: set! set-cdr! set-car! '

; TODO: symbol->string string->symbol
; TODO: number->string string->number
; TODO: string->list list->string

; ============== ALIASES ================
(define empty? null?)
(define eqv? eq?)
(define = eq?)
(define else #t)
(define / quotient)

; ============== MACROS ================
(define-macro (if x y z)
  (list (quote cond) (list x y) (list else z)))

; TODO: case let let* letrec begin do quasiquote for-each
; TODO: force delay

; ============== SYMBOLS ================
; (none)

; ============== BOOLEANS ================
(define (boolean? x)
  (or (eq? x #t) (eq? x #f)))
(define-macro (and . clauses)
  (cond ((null? clauses) #t)
        ((null? (cdr clauses)) (car clauses))
        (else
            (list (quote if) (car clauses)
                             (cons (quote and) (cdr clauses))
                             #f))))
(define-macro (or . clauses) ; Note - this evaluates the truthy clause twice
  (cond ((null? clauses) #f)
        (else
            (list (quote if) (car clauses)
                             (car clauses)
                             (cons (quote or) (cdr clauses))))))
(define (not x) (if x #f #t))

; ============== HELPERS ================
; Helpers for later definitions
(define (map f l) ; todo varargs
  (if (null? l) l
      (cons (f (car l))
            (map f (cdr l)))))
(define (foldl proc init lst) ; todo vargs
  (if (null? lst)
      init
      (foldl proc (proc init (car lst)) (cdr lst))))
(define (foldr proc init lst) ; todo vargs
  (foldl proc init (reverse lst)))
(define (filter pred lst)
  (if (null? lst)
      lst
      (if (pred (car lst))
          (cons (car lst) (filter pred (cdr lst)))
          (filter pred (cdr lst)))))
  
; TODO: equal? 

; ============== NUMBERS ================
; Upgrade to builtins to support not exactly 2 arguments: - + * / < <= > >= =
; TODO: < <= > >= =
(define _builtin- -)
(define _builtin+ +)
(define _builtin* *)
(define _builtin/ /)
(define _builtin< <)
(define (+ . lst)
    (cond ((null? lst) (error "WRONG_NUM_ARGUMENTS"))
          (else (foldl _builtin+ 0 lst))))
(define (- . lst)
    (cond ((= (length lst) 1) (_builtin- 0 (car lst)))
          ((= (length lst) 2) (_builtin- (car lst) (cadr lst)))
          (else (error "WRONG_NUM_ARGUMENTS"))))
(define (* . lst) (foldl _builtin* 1 lst))
(define (/ . lst)
    (cond ((null? lst) (error "WRONG_NUM_ARGUMENTS"))
          ((= (length lst) 1) (_builtin/ 1 (car lst)))
          (else (foldl _builtin/ (car lst) (cdr lst)))))

(define (max . lst)
  (foldl (lambda (x y) (if (< x y) y x))
         (car lst)
         (cdr lst)))
(define (min . lst)
  (foldl (lambda (x y) (if (< x y) x y))
         (car lst)
         (cdr lst)))
(define (negative? x) (< x 0))
(define (positive? x) (< 0 x))
(define (zero? x) (= x 0))
(define (remainder x y) ; Probably not correct
 (- x (* (quotient x y) y)))
(define modulo remainder)
(define (even? x) (= (modulo x 2) 0))
(define (odd? x) (= (modulo x 2) 1))
(define (abs x)
 (if (negative? x) (- x) x))

; TODO: gcd lcm expt
; TODO: range

; ============== LISTS AND PAIRS ================
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))
(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)
(define fourth cadddr)
(define (fifth x) (car (cddddr x)))
(define (sixth x) (cadr (cddddr x)))
(define (seventh x) (caddr (cddddr x)))
(define (eighth x) (cadddr (cddddr x)))
(define (ninth x) (car (cddddr (cddddr x))))
(define (tenth x) (cadr (cddddr (cddddr x))))

(define (last l)
 (if (null? (cdr l))
     (car l)
     (last (cdr l))))
(define (list? l)
 (if (null? l) 
     #t
     (if (pair? l)
         (list? (cdr l))
         #f)))
(define (length l)
  (if (null? l)
      0
      (+ 1 (length (cdr l)))))
(define (append l1 l2) ; todo varargs
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
(define (reverse l)
  (if (null? l)
      l
      (append (reverse (cdr l)) (list (car l)))))
(define (list-tail lst pos)
  (if (= pos 0) lst
      (list-tail (cdr lst) (- pos 1))))
(define (list-ref lst pos)
  (car (list-tail lst pos)))

(define (remove v lst proc) ; todo proc=equal? optional
  (if (null? lst) lst
      (if (proc v (car lst))
          (cdr lst)
          (cons (car lst) (remove v (cdr lst) proc)))))
(define (remq v lst) (remove v lst eq?))
(define (remv v lst) (remove v lst eqv?))

(define (assf pred lst)
  (if (null? lst)
      #f
      (if (pred (caar lst))
          (car lst)
          (assf pred (cdr lst)))))
(define (assoc v lst is-equal?) ; todo is-equal?=equal? is optional
  (assf (lambda (k) (is-equal? k v))
        lst))
(define (assv v lst) (assoc v lst eqv?))
(define (assq v lst) (assoc v lst eq?))

; TODO: memq memv member

; ============== CHARACTERS ================
; char->integer integer->char
; char? char=? char<? char>? char<=? char>=?
; char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?
; char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case?
; char-upcase char-downcase
; ============== STRINGS ================
; TODO: symbol->string string->symbol
; TODO: number->string string->number
; TODO: string->list list->string
; TODO: string? string string-length string-ref string=? string-ci=? string<? string>? string<=? string>=? string-ci<? string-ci>? string-ci<=? string-ci>=? substring string-append

; ============== I/O ================
; write display newline

; read read-char peek-char eof-object? char-ready? write display newline write-char

; load transcript-on transcript-off call-with-input-file call-with-output-file input-port? output-port? current-input-port current-output-port with-input-from-file with-output-to-file open-input-file open-output-file close-input-port close-output-port

; ============== CONTINUATIONS AND ENVIRONMENT ================
; scheme-report-environment null-environment interaction-environment
; call-with-current-continuation values call-with-values call-with-values dynamic-wind

; ============== MISC ================

; TODO: standard error messages
; TODO: support default values in lambda syntax?
